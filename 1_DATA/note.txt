"""
    danh sách quản lí Dictionary
    danh sách truy cập Set {1,2,3,4,5} -> tính duy nhất
    danh sách truy cập Array [1,2,3,4, 4]
    danh sách truy cập Tuple (1,2,3,4,4) -> tính bất biến
"""
phía dev -> danh sách truy cạp -> tính duy nhất HS 
phía user -> đám bảo chính xác thông tin user  -> tính bất biến
---
Bộ sưu tập -> tính duy nhất     + RULE  -> ko thể thay đổi luật vô hình này => tuân theo 
HĐ quan tọng -> itnsh bát biến  + RULE

# toán tử IN tỏng comprehension sẽ cho ra res mội lần lặp -> chứ ko phải cahjy hết 1 lần  

> DICTIONARY 

# init  -> form tuple -> 1 ARR , 2 ARR
# get  -> keys -> values-> items-> -> setdefault -> copy -> update -> pop -> clear 
# 2 dict -> 1 dict -> all() | any()

<-KHÔNG GIAN CẤU TRÚC-> 
    | # # # # # # |
    | # # # # # # | 
    | # # # # # # |
    | # # # # # # |

-------------------------------     -> CHECKING 
    ^             |    SORT,REVERSE
    |             V          | 
   NHẬP          XUẤT       SỮA     XOÁ
    ^              |         |       |
    |              V         v       v
   TẠO           SIZE       EDIT    POP,CLEAR 
                   |
                   V
                len, count, min, max(INDEX)
                   |
                   v
                INDEX- VALUES(1 OR 1.)

frozenset -> id -> hash
# 2 dict -> 1 dict -> all() | any()


# init  -> form tuple -> 1 ARR , 2 ARR
# get  -> keys -> values-> items-> -> setdefault -> copy -> update -> pop -> clear 
# 2 dict -> 1 dict -> all() | any()

d = dict(name = "tienthien", skills=["python", "java"], age=25)
d3 = dict([("a", 60), ("coin", 100)])
d4 = dict.fromkeys(["a", "b","c"], 9)
d5 = {k:v for k,v in zip("akjfhd", range(7))}

d6 = d3 | d4
print({**d6})

 • clear                → D
 • copy                 → D
 • fromkeys             → Create a new dictionary with keys from iterable and values set to value
 • get                  → Return the value for key if key is in the dictionary, else default
 • items                → D
 • keys                 → D
 • pop                  → D
 • popitem              → Remove and return a (key, value) pair as a 2-tuple
 • setdefault           → Insert key with a value of default if key is not in the dictionary
 • update               → D
 • values               → D
------LIST----
# sao chép nhân *
# slice truy cập
# len-> sum-> max-> min  
# count -> index
# add 
# Int Arr -> Str Arr -> gen 1  -> gen Arr 
[x for x in range(3)]
[0] * 3
list('abc')
list(range(3))
a[1:1] = [2,4,54]
a[1:1] = [7]
a[1:1] = []
a[-1]
a[0:-1:2]
a += [9]
                           3. THÊM PHẦN TỬ
======================================================================
l_temp.append(6)                              | Thêm vào cuối                | Kết quả: [1, 2, 3, 4, 5, 6]
l_temp.insert(1, 1.5)                         | Thêm tại vị trí              | Kết quả: [1, 1.5, 2, 3, 4, 5, 6]
l_temp.extend([7, 8])                         | Mở rộng list                 | Kết quả: [1, 1.5, 2, 3, 4, 5, 6, 7, 8]
l_temp += [9]                                 | Nối list bằng +=             | Kết quả: [1, 1.5, 2, 3, 4, 5, 6, 7, 8, 9]

======================================================================
                            4. XÓA PHẦN TỬ
======================================================================
l_temp.remove(3)                              | Xóa phần tử đầu tiên         | Kết quả: [1, 2, 4, 5]
l_temp.pop(1)                                 | Xóa và lấy phần tử tại vị trí | Kết quả: popped=2, l_temp=[1, 4, 5]
l_temp.pop()                                  | Xóa phần tử cuối             | Kết quả: [1, 4]
l_temp.clear()                                | Xóa toàn bộ list             | Kết quả: []

======================================================================
                            5. SỬA PHẦN TỬ
======================================================================
l_temp[0] = 10                                | Sửa phần tử tại vị trí       | Kết quả: [10, 2, 3, 4, 5]
l_temp[1:3] = [20, 30]                        | Sửa slice                    | Kết quả: [10, 20, 30, 4, 5]

======================================================================
                      6. KIỂM TRA TÍNH CHẤT LIST
======================================================================
2 in l_numbers                                | Kiểm tra phần tử có trong list | Kết quả: True
len(l_numbers)                                | Độ dài list                  | Kết quả: 5
min(l_numbers)                                | Giá trị nhỏ nhất             | Kết quả: 1
max(l_numbers)                                | Giá trị lớn nhất             | Kết quả: 5
sum(l_numbers)                                | Tổng các phần tử số          | Kết quả: 15
l_numbers.count(2)                            | Đếm số lần xuất hiện         | Kết quả: 1
l_numbers.index(3)                            | Tìm vị trí phần tử           | Kết quả: 2

======================================================================
                       7. SẮP XẾP VÀ ĐẢO NGƯỢC
======================================================================
l_temp.sort()                                 | Sắp xếp tăng dần             | Kết quả: [1, 2, 3, 4, 5]
l_temp.sort(reverse=True)                     | Sắp xếp giảm dần             | Kết quả: [5, 4, 3, 2, 1]
l_temp.reverse()                              | Đảo ngược list               | Kết quả: [5, 2, 4, 1, 3]
sorted(l_numbers)                             | Sắp xếp không sửa list       | Kết quả: [1, 2, 3, 4, 5]

======================================================================
                        8. LIST COMPREHENSION
======================================================================
[x*2 for x in l_numbers]                      | Nhân đôi phần tử             | Kết quả: [2, 4, 6, 8, 10]
[x for x in l_numbers if x > 2]               | Lọc phần tử > 2              | Kết quả: [3, 4, 5]
[[x, x**2] for x in range(3)]                 | Tạo list lồng nhau           | Kết quả: [[0, 0], [1, 1], [2, 4]]

======================================================================
                       9. XỬ LÝ LIST LỒNG NHAU
======================================================================
l_nested[1][0]                                | Truy cập phần tử lồng nhau   | Kết quả: 3
l_nested_copy[1][0] = 30                      | Sửa phần tử lồng nhau        | Kết quả: [[1, 2], [30, 4], [5, 6]]
[item for sublist in l_nested for item in sublist] | Làm phẳng list               | Kết quả: [1, 2, 3, 4, 5, 6]

======================================================================
                     10. KẾT HỢP VÀ SAO CHÉP LIST
======================================================================
l_numbers + l_str                             | Nối hai list                 | Kết quả: [1, 2, 3, 4, 5, 'Xin', 'chào', 'Python']    
l_numbers * 2                                 | Lặp lại list                 | Kết quả: [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]
l_numbers.copy()                              | Sao chép nông                | Kết quả: [1, 2, 3, 4, 5]
deepcopy(l_nested)                            | Sao chép sâu                 | Kết quả: [[1, 2], [3, 4], [5, 6]]

======================================================================
                         11. CHUYỂN ĐỔI LIST
======================================================================
tuple(l_numbers)                              | Chuyển sang tuple            | Kết quả: (1, 2, 3, 4, 5)
set(l_numbers)                                | Chuyển sang set              | Kết quả: {1, 2, 3, 4, 5}
','.join(l_str)                               | Chuyển list chuỗi sang chuỗi | Kết quả: Xin,chào,Python
dict(zip(l_str, l_numbers))                   | Chuyển sang dict             | Kết quả: {'Xin': 1, 'chào': 2, 'Python': 3}


---tuple -- tính bất biến  ---
t1 = (42,)
t2 = (1, 2, *t_numbers)
(0,) * 3 
tuple(sorted(t_numbers)) 
a, b, c = t_str                     | Giải nén cơ bản              | Kết quả: a=Xin, b=chào, c=Python
first, *rest = t_numbers            | Giải nén với *               | Kết quả: first=1, rest=[2, 3, 4, 5]
*start, last = t_numbers            | Giải nén lấy cuối            | Kết quả: start=[1, 2, 3, 4], last=5


---set -- tính duy nhất -- 
s_empty = set()                     | Set rỗng                     | Kết quả: set()
s_numbers = {1, 2, 3}               | Set số                       | Kết quả: {1, 2, 3, 4, 5}
s_mixed = {1, 'hello', 3.14}        | Set hỗn hợp                  | Kết quả: {'hello', 3.14, 1}
set([1, 2, 2, 3])                   | Từ list (loại bỏ trùng lặp)  | Kết quả: {1, 2, 3}
set('abc')                          | Từ chuỗi                     | Kết quả: {'b', 'a', 'c'}
{x for x in range(3)}               | Set comprehension            | Kết quả: {0, 1, 2}
frozenset([1, 2, 3])                | Tạo frozenset (bất biến)     | Kết quả: frozenset({1, 2, 3})

# 3. THÊM PHẦN TỬ
s_temp.add(6)                       | Thêm một phần tử             | Kết quả: {1, 2, 3, 4, 5, 6}
s_temp.update([7, 8])               | Thêm nhiều phần tử           | Kết quả: {1, 2, 3, 4, 5, 6, 7, 8}
s_frozen.add(4)                     | Thêm vào frozenset (lỗi)     | Kết quả: Lỗi: 'frozenset' object has no attribute 'add'

# 4. XÓA PHẦN TỬ
s_temp.remove(3)                    | Xóa phần tử (lỗi nếu không có) | Kết quả: {1, 2, 4, 5}
s_temp.discard(10)                  | Xóa phần tử (không lỗi)      | Kết quả: {1, 2, 4, 5}
s_temp.pop()                        | Xóa và lấy phần tử ngẫu nhiên | Kết quả: popped=1, s_temp={2, 4, 5}
s_temp.clear()                      | Xóa toàn bộ set              | Kết quả: set()

# 5. CÁC PHÉP TOÁN TẬP HỢP
s_numbers | s_numbers2              | Hợp (union)                  | Kết quả: {1, 2, 3, 4, 5, 6, 7}
s_numbers & s_numbers2              | Giao (intersection)          | Kết quả: {4, 5}
s_numbers - s_numbers2              | Hiệu (difference)            | Kết quả: {1, 2, 3}
s_numbers ^ s_numbers2              | Hiệu đối xứng (symmetric diff) | Kết quả: {1, 2, 3, 6, 7}
s_numbers.issubset({1, 2, 3, 4, 5, 6}) | Là tập con?                  | Kết quả: True
s_numbers.issuperset({1, 2})        | Là tập cha?                  | Kết quả: True
{1, 2}.isdisjoint({3, 4})           | Không giao nhau?             | Kết quả: True

 6. CẬP NHẬT TẬP HỢP
 s_temp.update([6, 7])               | Cập nhật hợp                 | Kết quả: {1, 2, 3, 4, 5, 6, 7}
s_temp.intersection_update(...)     | Cập nhật giao                | Kết quả: {4, 5}
s_temp.difference_update({1, 2})    | Cập nhật hiệu                | Kết quả: {3, 4, 5}
s_temp.symmetric_difference_update(...) | Cập nhật hiệu đối xứng       | Kết quả: {1, 2, 4, 5, 6, 7}
 • add                  → Add an element to a set
 • clear                → Remove all elements from this set
 • copy                 → Return a shallow copy of a set
 • difference           → Return the difference of two or more sets as a new set
 • difference_update    → Remove all elements of another set from this set
 • discard              → Remove an element from a set if it is a member
 • intersection         → Return the intersection of two sets as a new set
 • intersection_update  → Update a set with the intersection of itself and another
 • isdisjoint           → Return True if two sets have a null intersection
 • issubset             → Report whether another set contains this set
 • issuperset           → Report whether this set contains another set
 • pop                  → Remove and return an arbitrary set element
 • remove               → Remove an element from a set; it must be a member
 • symmetric_difference → Return the symmetric difference of two sets as a new set
 • symmetric_difference_update → Update a set with the symmetric difference of itself and another
 • union                → Return the union of sets as a new set
 • update               → Update a set with the union of itself and others