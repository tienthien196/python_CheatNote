#---Binary---nh·ªã ph√¢n ----
n = 0b0101
y = 0B0101

#---Octal ----b√°t ph√¢n ----
e = 0o23
f = 0O12

# ---hexadecimal--th·∫≠p l·ª•c ph√¢n
g = 0xAF
h = 0X12EF

x = 255

# print(x)           # 255 (th·∫≠p ph√¢n)
# print(bin(x))      # 0b11111111
# print(oct(x))      # 0o377
# print(hex(x))      # 0xff


#---Decimal ----h·ªá c∆° s·ªë 10 

# l∆∞u √Ω  type annotation(ch√∫ th√≠ch ki·ªÉu ) ko h·ªÅ ·∫£nh h∆∞·ªüng ƒë√©n runtime -> muon b·∫Øt l·ªói d√πng mypy
i: int = 34.6798 # out float -> ph·∫£i √©p v·ªÅ int

# Floating-point arithmetic limitations
# IEEE 754 representation error
# Binary floating-point inaccuracy
# Decimal fraction representation problem
i2 = 0.5 + 0.3 # 
# print((1.2+0.3)== 1.5)
# d√πng under scop cho bi·∫øn ko d√πng trong loop 
# d√πng ƒë·ªÉ t√°ch s·ªë >> hi·ªÉn th·ªã ƒë·∫πp >> ko ·∫£nh h∆∞·ªüng value
l = 1_00_0000
m = 0b01_10

# l∆∞u √Ω  :numeric literals , c√°c e, E ƒë·ªÅu l√† float >> exponent(c∆° s·ªë m≈©)
b = 1E5 # out  1*10^5
d = 2e3 # out 2*10^3
c = 2.5E-3 # 2.5*10^-3
#--- complex----
v: complex = 3+4j 
# S·ªë ph·ª©c kh√¥ng so s√°nh ƒë∆∞·ª£c



# print(l)
# print(c)
# print(i) 
# print(type(i))
# print(type(b))

# print(help(input))



### NG√ÄY 2
#----G√°n ----- >> value t∆∞∆°ng ·ª©ng
x1 = 6
o1 = x1 =5 #  thay ƒë·ªïi 1 ·∫£nh h∆∞·ªüng 2
o1 += 5
o1 -= 5
o1 *= 5
o1 /= 5
o1 %= 5
o1 //=5
o1 **=5
# print(x1)

#---to√°n t·ª≠ so s√°nh --- >> True / False
1 < 6 < 100 # pythonic
5 == 5
5 != 3
5 > 3
5 < 3
5 >= 3
5 <= 3
# print(b1)
# print(5| 5)
# print(5 & 5)

# ---to√°n t·ª≠ logic  ---- >> value 
a1 = [] or "" # -> []
b1 = "hi:" or [1,2] or "hello"     # ‚Üí hi:
c1 = "" or [] or [1]      # ‚Üí [1] (v√¨ "" v√† [] ƒë·ªÅu falsy)
# return true ƒë·∫ßu ti√™n  or flase cu·ªëi c√πng n·∫øu ko c√≥ true n√†o

c2 = [1,2] and "hello" # >hello
d1 = None and [] # []
# print(bool([1,2] or "hello"))
# input_name  = input("can")
# name = input_name or "Anonymous"
# return true cu·ªëi or flase ƒë·∫ßu ti√™n

c2 is bool # is l√† check 2 bi·∫øn c√≥ c√πng tr·ªè 1 √¥ nh·ªõ ko ? Tr·ª´ x is None
c2 in [] # in check th√†nh vi√™n c√≥ trong iterable 
isinstance(x, bool) # check xem bi·∫øn c√≥ thu·ªôc class hay kh ?

# --- bitwise --- >> bit c·ªßa s·ªë nguy√™n
# [1,2] & [3] >> l·ªói bitwise kh√¥ng d√πng cho list >> ch·ªâ d√πng cho int v√† bool
# 5 = 101 , 3 = 011, 5 & 3 >> 001 >> out -> 1
# 5 | 3 >> 111 > out -> 7
# NOT bit(ƒë·∫£o bit) ~5 >> ~n = -(n+1)>> out -> -6 
# ~-6 >> out -> 5

5 << 1  # 5 * 2^1 = 10 >>[x *  2‚Åø]
5 << 2  # 5 * 4 = 20 
# 5 = 101 5 << 1 = 1010 ‚Üí 10

10 >> 1  # 10 // 2 = 5 >> [x / 2‚Åø]
10 >> 2  # 10 // 4 = 2
# print(10 >> 1)  # ‚Üí 5
# print(-10 >> 1) # ‚Üí -5 (Python gi·ªØ d·∫•u)

#XOR = not and  Exclusive OR
#giao ho√°n xor a ^ b == b ^ a  , (a ^ b) ^ c == a ^ (b ^ c) , a ^ a == 0, a ^ 0 == a
# Kh·∫£ ngh·ªãch: if c = a ^ b -> a = c ^ b , b = c ^ a


# if x & 1:      # ki·ªÉm tra x c√≥ l·∫ª kh√¥ng ‚Üí ƒë√∫ng
# if x and 1:    # lu√¥n True n·∫øu x ‚â† 0 ‚Üí KH√îNG ph·∫£i ki·ªÉm tra bit!


# READ = 4   # 100
# WRITE = 2  # 010
# EXEC = 1   # 001

# permission = READ | WRITE  # 110 ‚Üí c√≥ quy·ªÅn ƒë·ªçc v√† ghi

# if permission & READ:
#     print("C√≥ quy·ªÅn ƒë·ªçc")

# ---ho√°n ƒë·ªïi xor ko c·∫ßn trung gian--
# a = 5
# b = 9
# a = a ^ b  # a = 5 ^ 9
# b = a ^ b  # b = (5 ^ 9) ^ 9 = 5
# a = a ^ b  # a = (5 ^ 9) ^ 5 = 9

# print(a, b)  # ‚Üí 9 5

# nums = [4, 1, 2, 1, 2]

# result = 0
# for x in nums:
#     result ^= x

# print(result)  # ‚Üí 4

# message = "Hello"
# key = 42

# # M√£ h√≥a: XOR t·ª´ng k√Ω t·ª± v·ªõi key
# encoded = [ord(c) ^ key for c in message]
# print("Encoded:", encoded)

# # Gi·∫£i m√£: XOR l·∫°i v·ªõi key
# decoded = ''.join(chr(b ^ key) for b in encoded)
# print("Decoded:", decoded)  # ‚Üí "Hello"

# def same_sign(a, b):
#     return (a ^ b) >= 0

# print(same_sign(5, 3))   # True
# print(same_sign(-5, 3))  # False


# üß† M·∫πo nh·ªõ nhanh (kh√¥ng c·∫ßn h·ªçc thu·ªôc) TH·ª® T·ª∞ ∆ØU TI√äN PH√âP TO√ÅN
# D·∫•u ngo·∫∑c () lu√¥n ƒë∆∞·ª£c t√≠nh ƒë·∫ßu ti√™n ‚Üí c·ª© nghi ng·ªù, th√™m ngo·∫∑c!
# S·ªë h·ªçc (**, *, /, +, -) ‚Üí nh∆∞ to√°n ph·ªï th√¥ng.
# Bitwise (<<, >>, &, ^, |) ‚Üí n·∫±m gi·ªØa s·ªë h·ªçc v√† so s√°nh.
# So s√°nh (==, !=, <, in, is) ‚Üí cao h∆°n not/and/or.
# Logic (not ‚Üí and ‚Üí or) ‚Üí ∆∞u ti√™n th·∫•p nh·∫•t (tr·ª´ g√°n).

# --- b·∫´y --->> CH√ö √ù D√ÅU NGO·∫∂C KHI D√ôNG TO√ÅN T·ª¨  
True == True and False # (True == True) and False 
5 & 3 == 1 # 5 & (3 == 1) Sai >> ph·∫£i s·ªØa (5 & 3) == 1  # ‚Üí True
2 ** 3 ** 2 # (2 ** 3) ** 2 Sai  >> 2 ** (3 ** 2) = 512 ƒê√∫ng
1 < 2 < 3 # so s√°nh chu·ªói  >> (1 < 2) and (2 < 3)
not x == y # kh√°c v·ªõi not (x == y)

# B·∫´y tham s·ªë FUNCTION (Mutable default argument)
# list += [1] ƒë∆∞·ª£c, nh∆∞ng tuple += (1,) t·∫°o object m·ªõi
# Nguy√™n nh√¢n: closure 'b·∫Øt' tham chi·∫øu ƒë·∫øn i, kh√¥ng ph·∫£i gi√° tr·ªã t·∫°i th·ªùi ƒëi·ªÉm
# Hi·ªÉu sai v·ªÅ "pass by object reference"

#--- b·∫´y 
x = "   "
if x:  # ‚Üí True! V√¨ chu·ªói kh√¥ng r·ªóng
    ...

y = -1
if y:  # ‚Üí True! V√¨ kh√°c 0
    ...

...
my_list = []

# ‚ùå Kh√¥ng Pythonic, d·ªÖ l·ªói n·∫øu ki·ªÉu d·ªØ li·ªáu thay ƒë·ªïi
if my_list == []:
    ...

# ‚úÖ Pythonic: d√πng truthiness
if not my_list:
    ...

...
status = "pending"

# ‚ùå Sai: lu√¥n True (v√¨ "approved" l√† truthy)
if status == "pending" or "approved":
    print("OK")  # Lu√¥n in!

# ‚úÖ ƒê√∫ng
if status == "pending" or status == "approved":
    ...

# ‚úÖ T·ªët h∆°n: d√πng `in`
if status in ("pending", "approved"):
    ...

...
x = 0
y = 5

# ‚ùå Hi·ªÉu nh·∫ßm: nghƒ© `x or y` tr·∫£ v·ªÅ True/False
if x or y:
    print("OK")  # In ra, v√¨ y truthy

# Nh∆∞ng:
result = x or y
print(result)  # ‚Üí 5, KH√îNG ph·∫£i True!

...
x = 0
y = 5

# ‚ùå Hi·ªÉu nh·∫ßm: nghƒ© `x or y` tr·∫£ v·ªÅ True/False
if x or y:
    print("OK")  # In ra, v√¨ y truthy

# Nh∆∞ng:
result = x or y
print(result)  # ‚Üí 5, KH√îNG ph·∫£i True!

# B·∫™Y TRONG V√íNG L·∫∂P
funcs = []
for i in range(3):
    funcs.append(lambda: print(i))

for f in funcs:
    f()  # In: 2, 2, 2 ‚Üí ‚ùå Mong mu·ªën: 0, 1, 2

...
nums = [1, 2, 3, 4, 5]
for x in nums:
    if x % 2 == 0:
        nums.remove(x)  # ‚ùå Nguy hi·ªÉm!

print(nums)  # ‚Üí [1, 3, 4, 5] ‚Üí 4 kh√¥ng b·ªã x√≥a!
# L√Ω do: Khi x√≥a ph·∫ßn t·ª≠, c√°c ph·∫ßn t·ª≠ sau d·ªãch v·ªÅ, con tr·ªè l·∫∑p b·ªè s√≥t ph·∫ßn t·ª≠ ti·∫øp theo. 
# ‚úÖ C√°ch s·ª≠a:

# L·∫∑p tr√™n b·∫£n sao: for x in nums[:]:
# D√πng list comprehension: nums = [x for x in nums if x % 2 != 0]
# L·∫∑p ng∆∞·ª£c: for i in range(len(nums)-1, -1, -1):

...
for i in range(3):
    if i == 5:
        break
else:
    print("Kh√¥ng g·∫∑p break")  # ‚úÖ In ra

# Nh∆∞ng:
for i in range(3):
    break
else:
    print("...")  # ‚ùå KH√îNG in
#  else trong v√≤ng l·∫∑p ‚Üí hi·ªÉu nh·∫ßm l√† "lu√¥n ch·∫°y"
#  else trong for/while ch·ªâ ch·∫°y n·∫øu v√≤ng l·∫∑p k·∫øt th√∫c b√¨nh th∆∞·ªùng (kh√¥ng b·ªã break). 

...
items = ['a', 'b', 'c']

# ‚ùå Kh√¥ng Pythonic
for i in range(len(items)):
    print(i, items[i])

# ‚úÖ D√πng `enumerate`
for i, item in enumerate(items):
    print(i, item)
# D√πng range(len(...)) khi kh√¥ng c·∫ßn thi·∫øt

...
d = {'a': 1, 'b': 2}

# ‚ùå Hi·ªÉu nh·∫ßm: nghƒ© l·∫∑p qua c·∫∑p (key, value)
for x in d:
    print(x)  # ‚Üí 'a', 'b' (ch·ªâ keys)

# ‚úÖ Mu·ªën c·∫∑p:
for k, v in d.items():
    ...
# L·ªñI PH·ªî BI·∫æN  
""" th·ª•c l·ªÅ sai 
if x > 0:
print("OK")  # ‚ùå IndentationError

# Ho·∫∑c t·ªá h∆°n: th·ª•t l·ªÅ sai nh∆∞ng kh√¥ng b√°o l·ªói ‚Üí logic sai
if x > 0:
    a = 1
    if y > 0:
    a = 2  # ‚ùå D√≤ng n√†y kh√¥ng thu·ªôc if y > 0!
"""

# B·∫™Y TRONG H√ÄM  

"""
1. LEGB Rule ‚Äì Quy t·∫Øc t√¨m ki·∫øm bi·∫øn
Python tu√¢n theo LEGB khi t√¨m bi·∫øn:

Local ‚Üí trong h√†m hi·ªán t·∫°i
Enclosing ‚Üí trong h√†m cha (closure)
Global ‚Üí trong module
Built-in ‚Üí nh∆∞ len, print, int, True...
"""

# ‚ùå SAI ‚Äì d√πng list/dict/set l√†m gi√° tr·ªã m·∫∑c ƒë·ªãnh
def add_item(item, target=[]):
    target.append(item)
    return target

print(add_item(1))  # [1]
print(add_item(2))  # [1, 2] ‚Üê G√å? MONG MU·ªêN: [2]
#  Mutable default argument (B·∫™Y KINH ƒêI·ªÇN!)
#s·ªØa  √Åp d·ª•ng cho: list, dict, set, [], {}, set(), custom object... 
def add_item(item, target=None):
    if target is None:
        target = []
    target.append(item)
    return target
...
counter = 0

def increment():
    counter += 1  # ‚ùå UnboundLocalError!

increment()
# Thay ƒë·ªïi bi·∫øn to√†n c·ª•c m√† kh√¥ng khai b√°o global
# L∆ØU √ù ƒê√ÇY L√Ä B√ÄI D√ôNG TR·ª∞C TI·∫æP GLOBAL , C√íN BAI THAM S·ªê TR√ôNG T√äN GLOBAL
# param tham s·ªë h√†m  , argument ƒë·ªëi s·ªë input
# s·ªØa >> ch·ªâ √°p d·ª•ng cho ki·ªÉu d·ªØ li·ªáu b·∫•t bi·∫øn immutable , mutable th√¨ tho·∫£i m√°i
def increment():
    global counter
    counter += 1
# t∆∞∆°ng t·ª± -------------
def outer():
    x = 0
    def inner():
        x += 1  # ‚ùå UnboundLocalError!
    inner()
# Thay ƒë·ªïi bi·∫øn trong closure m√† kh√¥ng khai b√°o nonlocal (Python 3+) >> S·ªÆA
def outer():
    x = 0
    def inner():
        nonlocal x
        x += 1
    inner()
    return x

...
# ‚ùå Sai c√∫ ph√°p
# def f(**kwargs, *args): ...

# ‚úÖ ƒê√∫ng: *args tr∆∞·ªõc **kwargs
def f(*args, **kwargs): ...

...
def modify_list(lst):
    lst.append(4)  # ·∫¢nh h∆∞·ªüng ƒë·∫øn list g·ªëc ‚Üí OK

def reassign_list(lst):
    lst = [1, 2, 3]  # ‚ùå Kh√¥ng ·∫£nh h∆∞·ªüng ƒë·∫øn list g·ªëc!

my_list = [10]
reassign_list(my_list)
print(my_list)  # [10] ‚Üê kh√¥ng ƒë·ªïi!
# ‚úÖ Python kh√¥ng c√≥ "pass by value" hay "pass by reference" ‚Äî m√† l√† "pass by object reference


# B·∫™Y TRONG try...except
def risky_code():...
# ‚ùå R·∫§T NGUY HI·ªÇM
try:
    risky_code()
except:  # B·∫Øt c·∫£ KeyboardInterrupt, SystemExit!
    pass
# s·ªØa 
def handle_error():...
try:
    risky_code()
except ValueError as e:
    handle_error(e)

...
# ‚ùå Sai: ch·ªâ b·∫Øt `TypeError`, b·ªè qua `ValueError`
# except TypeError, ValueError:  # C√ö PH√ÅP L·ªñI ·ªü Python 3!
# s·ªØa >> 
try:...
except (TypeError, ValueError) as e:
    ...

...
try:
    x = 1 / 0
except ZeroDivisionError:
    print("L·ªói")
else:
    print("Kh√¥ng l·ªói")  # ‚ùå KH√îNG ch·∫°y
finally:
    print("Lu√¥n ch·∫°y")  # ‚úÖ Ch·∫°y
# D√πng else v√† finally kh√¥ng hi·ªÉu r√µ
# else: ch·ªâ ch·∫°y n·∫øu kh√¥ng c√≥ exception
# finally: lu√¥n ch·∫°y, k·ªÉ c·∫£ c√≥ return, break, continue

...
def f():
    try:
        return "from try"
    finally:
        return "from finally"  # ‚úÖ Ghi ƒë√®!

print(f())  # "from finally"
# ‚Üí C·∫©n th·∫≠n khi return trong finally! 

...
def risky():...
try:
    risky()
except ValueError:
    print("C√≥ l·ªói")  # ‚ùå M·∫•t th√¥ng tin l·ªói g·ªëc!

# s·ªØa  >>
import logging

try:
    risky()
except ValueError as e:
    logging.exception("L·ªói khi x·ª≠ l√Ω")  # Gi·ªØ nguy√™n stack trace
    # ho·∫∑c raise l·∫°i: raise

...
try:
    risky()
except ValueError:
    # ‚ùå M·∫•t stack trace g·ªëc
    raise ValueError("L·ªói m·ªõi")

# ‚úÖ Gi·ªØ nguy√™n stack trace
except ValueError:
    raise  # ‚Üê kh√¥ng c√≥ ƒë·ªëi s·ªë

# Ho·∫∑c: chain exception (Python 3)
except ValueError as e:
    raise RuntimeError("L·ªói m·ªõi") from e

# raise l·∫°i exception sai c√°ch ‚Üí m·∫•t stack trace g·ªëc

...
my_dict = {}
# ‚ùå Kh√¥ng c·∫ßn thi·∫øt ‚Äì d√πng if t·ªët h∆°n
try:
    value = my_dict['key']
except KeyError:
    value = None

# ‚úÖ T·ªët h∆°n:
value = my_dict.get('key')
#  D√πng try...except ƒë·ªÉ ki·ªÉm tra ƒëi·ªÅu ki·ªán (EAFP vs LBYL) ‚Äì l·∫°m d·ª•ng
# ‚Üí EAFP ("Easier to Ask for Forgiveness than Permission") l√† phong c√°ch Python,
# nh∆∞ng ƒë·ª´ng l·∫°m d·ª•ng khi c√≥ c√°ch ƒë∆°n gi·∫£n h∆°n. 


# config.py
DEBUG = True

# main.py
import config
config.DEBUG = False  # ‚úÖ OK

# Nh∆∞ng n·∫øu b·∫°n l√†m:
from config import DEBUG
DEBUG = False  # ‚ùå Ch·ªâ g√°n local trong main.py, kh√¥ng ƒë·ªïi config.DEBUG!
# ƒê√¢y l√† b·∫´y "import by value vs by reference" ‚Äî th·ª±c ch·∫•t l√† rebinding name. 

...
# exec() v√† eval() ‚Äì ph·∫°m vi ƒë·ªông (dynamic scope)
#  exec/eval ph√° v·ª° LEGB th√¥ng th∆∞·ªùng ‚Üí d·ªÖ g√¢y l·ªói b·∫£o m·∫≠t v√† debug kh√≥. 
x = 10
exec("print(x)")  # ‚Üí 10 ‚úÖ

def f():
    x = 20
    exec("print(x)")  # ‚Üí 20 ‚úÖ

f()

...
x = "global"

class A:
    x = "class"
    def method(self):
        return x  # ‚Üí "global", KH√îNG ph·∫£i "class"!

print(A().method())  # "global" ‚úÖ
#  Class scope ‚Äì kh√¥ng ph·∫£i l√† enclosing scope!

# ‚ùó Ph·∫°m vi l·ªõp (class scope) KH√îNG ƒë∆∞·ª£c t√¨m trong LEGB khi ·ªü trong method!
# ‚Üí Method ch·ªâ th·∫•y: Local ‚Üí Enclosing (n·∫øu c√≥ closure) ‚Üí Global ‚Üí Built-in. 
class A:
    x = "A"

    def get_via_self(self):
        return self.x

    def get_via_class(self):
        return self.__class__.x

    def get_via_A(self):
        return A.x

class B(A):
    x = "B"

b = B()

print(b.get_via_self())     # ‚Üí "B" ‚úÖ (k·∫ø th·ª´a + override)
print(b.get_via_class())    # ‚Üí "B" ‚úÖ (l·∫•y t·ª´ l·ªõp th·ª±c t·∫ø c·ªßa b)
print(b.get_via_A())        # ‚Üí "A" ‚ùå (c·ª©ng v√†o A, kh√¥ng theo subclass!)