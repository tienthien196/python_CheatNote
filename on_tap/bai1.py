#---Binary---nh·ªã ph√¢n ----
print(0b0101)
print(0B1111)
#---Octal ----b√°t ph√¢n ----
print(0o7777)
print(0O4567)

# ---hexadecimal--th·∫≠p l·ª•c ph√¢n
print(0x0000)
print(0XFFFF)

#---Decimal ----h·ªá c∆° s·ªë 10 
x = 255
print(x)           # 255 (th·∫≠p ph√¢n)
print(bin(x))      # 0b11111111
print(oct(x))      # 0o377
print(hex(x))      # 0xff







# print(l)
# print(c)
# print(i) 
# print(type(i))
# print(type(b))

# print(help(input))




#---to√°n t·ª≠ so s√°nh --- >> True / False
1 < 6 < 100 # pythonic
5 == 5
5 != 3
5 > 3
5 < 3
5 >= 3
5 <= 3
# print(b1)
# print(5| 5)
# print(5 & 5)



# --- bitwise --- >> bit c·ªßa s·ªë nguy√™n
# [1,2] & [3] >> l·ªói bitwise kh√¥ng d√πng cho list >> ch·ªâ d√πng cho int v√† bool
# 5 = 101 , 3 = 011, 5 & 3 >> 001 >> out -> 1
# 5 | 3 >> 111 > out -> 7
# NOT bit(ƒë·∫£o bit) ~5 >> ~n = -(n+1)>> out -> -6 
# ~-6 >> out -> 5

5 << 1  # 5 * 2^1 = 10 >>[x *  2‚Åø]
5 << 2  # 5 * 4 = 20 
# 5 = 101 5 << 1 = 1010 ‚Üí 10

10 >> 1  # 10 // 2 = 5 >> [x / 2‚Åø]
10 >> 2  # 10 // 4 = 2
# print(10 >> 1)  # ‚Üí 5
# print(-10 >> 1) # ‚Üí -5 (Python gi·ªØ d·∫•u)

#XOR = not and  Exclusive OR
#giao ho√°n xor a ^ b == b ^ a  , (a ^ b) ^ c == a ^ (b ^ c) , a ^ a == 0, a ^ 0 == a
# Kh·∫£ ngh·ªãch: if c = a ^ b -> a = c ^ b , b = c ^ a


# if x & 1:      # ki·ªÉm tra x c√≥ l·∫ª kh√¥ng ‚Üí ƒë√∫ng
# if x and 1:    # lu√¥n True n·∫øu x ‚â† 0 ‚Üí KH√îNG ph·∫£i ki·ªÉm tra bit!


# READ = 4   # 100
# WRITE = 2  # 010
# EXEC = 1   # 001

# permission = READ | WRITE  # 110 ‚Üí c√≥ quy·ªÅn ƒë·ªçc v√† ghi

# if permission & READ:
#     print("C√≥ quy·ªÅn ƒë·ªçc")

# ---ho√°n ƒë·ªïi xor ko c·∫ßn trung gian--
# a = 5
# b = 9
# a = a ^ b  # a = 5 ^ 9
# b = a ^ b  # b = (5 ^ 9) ^ 9 = 5
# a = a ^ b  # a = (5 ^ 9) ^ 5 = 9

# print(a, b)  # ‚Üí 9 5

# nums = [4, 1, 2, 1, 2]

# result = 0
# for x in nums:
#     result ^= x

# print(result)  # ‚Üí 4

# message = "Hello"
# key = 42

# # M√£ h√≥a: XOR t·ª´ng k√Ω t·ª± v·ªõi key
# encoded = [ord(c) ^ key for c in message]
# print("Encoded:", encoded)

# # Gi·∫£i m√£: XOR l·∫°i v·ªõi key
# decoded = ''.join(chr(b ^ key) for b in encoded)
# print("Decoded:", decoded)  # ‚Üí "Hello"

# def same_sign(a, b):
#     return (a ^ b) >= 0

# print(same_sign(5, 3))   # True
# print(same_sign(-5, 3))  # False


# üß† M·∫πo nh·ªõ nhanh (kh√¥ng c·∫ßn h·ªçc thu·ªôc) TH·ª® T·ª∞ ∆ØU TI√äN PH√âP TO√ÅN
# D·∫•u ngo·∫∑c () lu√¥n ƒë∆∞·ª£c t√≠nh ƒë·∫ßu ti√™n ‚Üí c·ª© nghi ng·ªù, th√™m ngo·∫∑c!
# ** to√°n t·ª≠ m≈© s·∫Ω th·ª±c thi t·ª´ ph·∫£i qua tr√°i 
# --- C√íN L·∫†I T·ª™ PH·∫¢I SANG TR√ÅI ---------
# S·ªë h·ªçc (*, /, //, %, +, -) ‚Üí nh∆∞ to√°n ph·ªï th√¥ng.
# Bitwise (<<, >>, &, ^, |) ‚Üí n·∫±m gi·ªØa s·ªë h·ªçc v√† so s√°nh.
# So s√°nh (==, !=, <, <=,  in, is, is not , not in) 
# Logic (not ‚Üí and ‚Üí or) ‚Üí ∆∞u ti√™n th·∫•p nh·∫•t (tr·ª´ g√°n).
x = 9; y= 9
# --- b·∫´y --->> CH√ö √ù D√ÅU NGO·∫∂C KHI D√ôNG TO√ÅN T·ª¨  
True == True and False # (True == True) and False 
5 & 3 == 1 # 5 & (3 == 1) Sai >> ph·∫£i s·ªØa (5 & 3) == 1  # ‚Üí True
2 ** 3 ** 2 # v·∫•n ƒë√∫ng v√¨ to√°n t·ª´ m≈© ch·∫°y t·ª´ ph·∫£i qua tr√°i 
1 < 2 < 3 # so s√°nh chu·ªói  >> (1 < 2) and (2 < 3)
not x == y # kh√°c v·ªõi not (x == y)

# B·∫´y tham s·ªë FUNCTION (Mutable default argument)
# list += [1] ƒë∆∞·ª£c, nh∆∞ng tuple += (1,) t·∫°o object m·ªõi
# Nguy√™n nh√¢n: closure 'b·∫Øt' tham chi·∫øu ƒë·∫øn i, kh√¥ng ph·∫£i gi√° tr·ªã t·∫°i th·ªùi ƒëi·ªÉm
# Hi·ªÉu sai v·ªÅ "pass by object reference"

#--- b·∫´y 
x = "   "
if x:  # ‚Üí True! V√¨ chu·ªói kh√¥ng r·ªóng
    ...

y = -1
if y:  # ‚Üí True! V√¨ kh√°c 0
    ...

...
my_list = []

# ‚ùå Kh√¥ng Pythonic, d·ªÖ l·ªói n·∫øu ki·ªÉu d·ªØ li·ªáu thay ƒë·ªïi
if my_list == []:
    ...

# ‚úÖ Pythonic: d√πng truthiness
if not my_list:
    ...

...
status = "pending"

# ‚ùå Sai: lu√¥n True (v√¨ "approved" l√† truthy)
if status == "pending" or "approved":
    print("OK")  # Lu√¥n in!

# ‚úÖ ƒê√∫ng
if status == "pending" or status == "approved":
    ...

# ‚úÖ T·ªët h∆°n: d√πng `in`
if status in ("pending", "approved"):
    ...

...
x = 0
y = 5

# ‚ùå Hi·ªÉu nh·∫ßm: nghƒ© `x or y` tr·∫£ v·ªÅ True/False
if x or y:
    print("OK")  # In ra, v√¨ y truthy

# Nh∆∞ng:
result = x or y
print(result)  # ‚Üí 5, KH√îNG ph·∫£i True!

...
x = 0
y = 5

# ‚ùå Hi·ªÉu nh·∫ßm: nghƒ© `x or y` tr·∫£ v·ªÅ True/False
if x or y:
    print("OK")  # In ra, v√¨ y truthy

# Nh∆∞ng:
result = x or y
print(result)  # ‚Üí 5, KH√îNG ph·∫£i True!

# B·∫™Y TRONG V√íNG L·∫∂P
funcs = []
for i in range(3):
    funcs.append(lambda: print(i))

for f in funcs:
    f()  # In: 2, 2, 2 ‚Üí ‚ùå Mong mu·ªën: 0, 1, 2

...
nums = [1, 2, 3, 4, 5]
for x in nums:
    if x % 2 == 0:
        nums.remove(x)  # ‚ùå Nguy hi·ªÉm!

print(nums)  # ‚Üí [1, 3, 4, 5] ‚Üí 4 kh√¥ng b·ªã x√≥a!
# L√Ω do: Khi x√≥a ph·∫ßn t·ª≠, c√°c ph·∫ßn t·ª≠ sau d·ªãch v·ªÅ, con tr·ªè l·∫∑p b·ªè s√≥t ph·∫ßn t·ª≠ ti·∫øp theo. 
# ‚úÖ C√°ch s·ª≠a:

# L·∫∑p tr√™n b·∫£n sao: for x in nums[:]:
# D√πng list comprehension: nums = [x for x in nums if x % 2 != 0]
# L·∫∑p ng∆∞·ª£c: for i in range(len(nums)-1, -1, -1):

...
for i in range(3):
    if i == 5:
        break
else:
    print("Kh√¥ng g·∫∑p break")  # ‚úÖ In ra

# Nh∆∞ng:
for i in range(3):
    break
else:
    print("...")  # ‚ùå KH√îNG in
#  else trong v√≤ng l·∫∑p ‚Üí hi·ªÉu nh·∫ßm l√† "lu√¥n ch·∫°y"
#  else trong for/while ch·ªâ ch·∫°y n·∫øu v√≤ng l·∫∑p k·∫øt th√∫c b√¨nh th∆∞·ªùng (kh√¥ng b·ªã break). 

...
items = ['a', 'b', 'c']

# ‚ùå Kh√¥ng Pythonic
for i in range(len(items)):
    print(i, items[i])

# ‚úÖ D√πng `enumerate`
for i, item in enumerate(items):
    print(i, item)
# D√πng range(len(...)) khi kh√¥ng c·∫ßn thi·∫øt

...
d = {'a': 1, 'b': 2}

# ‚ùå Hi·ªÉu nh·∫ßm: nghƒ© l·∫∑p qua c·∫∑p (key, value)
for x in d:
    print(x)  # ‚Üí 'a', 'b' (ch·ªâ keys)

# ‚úÖ Mu·ªën c·∫∑p:
for k, v in d.items():
    ...
# L·ªñI PH·ªî BI·∫æN  
""" th·ª•c l·ªÅ sai 
if x > 0:
print("OK")  # ‚ùå IndentationError

# Ho·∫∑c t·ªá h∆°n: th·ª•t l·ªÅ sai nh∆∞ng kh√¥ng b√°o l·ªói ‚Üí logic sai
if x > 0:
    a = 1
    if y > 0:
    a = 2  # ‚ùå D√≤ng n√†y kh√¥ng thu·ªôc if y > 0!
"""

# B·∫™Y TRONG H√ÄM  

"""
1. LEGB Rule ‚Äì Quy t·∫Øc t√¨m ki·∫øm bi·∫øn
Python tu√¢n theo LEGB khi t√¨m bi·∫øn:

Local ‚Üí trong h√†m hi·ªán t·∫°i
Enclosing ‚Üí trong h√†m cha (closure)
Global ‚Üí trong module
Built-in ‚Üí nh∆∞ len, print, int, True...
"""

# ‚ùå SAI ‚Äì d√πng list/dict/set l√†m gi√° tr·ªã m·∫∑c ƒë·ªãnh
def add_item(item, target=[]):
    target.append(item)
    return target

print(add_item(1))  # [1]
print(add_item(2))  # [1, 2] ‚Üê G√å? MONG MU·ªêN: [2]
#  Mutable default argument (B·∫™Y KINH ƒêI·ªÇN!)
#s·ªØa  √Åp d·ª•ng cho: list, dict, set, [], {}, set(), custom object... 
def add_item(item, target=None):
    if target is None:
        target = []
    target.append(item)
    return target
...
counter = 0

def increment():
    counter += 1  # ‚ùå UnboundLocalError!

increment()
# Thay ƒë·ªïi bi·∫øn to√†n c·ª•c m√† kh√¥ng khai b√°o global
# L∆ØU √ù ƒê√ÇY L√Ä B√ÄI D√ôNG TR·ª∞C TI·∫æP GLOBAL , C√íN BAI THAM S·ªê TR√ôNG T√äN GLOBAL
# param tham s·ªë h√†m  , argument ƒë·ªëi s·ªë input
# s·ªØa >> ch·ªâ √°p d·ª•ng cho ki·ªÉu d·ªØ li·ªáu b·∫•t bi·∫øn immutable , mutable th√¨ tho·∫£i m√°i
def increment():
    global counter
    counter += 1
# t∆∞∆°ng t·ª± -------------
def outer():
    x = 0
    def inner():
        x += 1  # ‚ùå UnboundLocalError!
    inner()
# Thay ƒë·ªïi bi·∫øn trong closure m√† kh√¥ng khai b√°o nonlocal (Python 3+) >> S·ªÆA
def outer():
    x = 0
    def inner():
        nonlocal x
        x += 1
    inner()
    return x

...
# ‚ùå Sai c√∫ ph√°p
# def f(**kwargs, *args): ...

# ‚úÖ ƒê√∫ng: *args tr∆∞·ªõc **kwargs
def f(*args, **kwargs): ...

...
def modify_list(lst):
    lst.append(4)  # ·∫¢nh h∆∞·ªüng ƒë·∫øn list g·ªëc ‚Üí OK

def reassign_list(lst):
    lst = [1, 2, 3]  # ‚ùå Kh√¥ng ·∫£nh h∆∞·ªüng ƒë·∫øn list g·ªëc!

my_list = [10]
reassign_list(my_list)
print(my_list)  # [10] ‚Üê kh√¥ng ƒë·ªïi!
# ‚úÖ Python kh√¥ng c√≥ "pass by value" hay "pass by reference" ‚Äî m√† l√† "pass by object reference


# B·∫™Y TRONG try...except

try: ...
except ZeroDivisionError: ... # 5 / 0  # ZeroDivisionError
except IndentationError as e: ... #  Sai d√≤ng vi·∫øt (d√πng tab v√† d·∫•u c√°ch, thi·∫øu d·∫•u l√≥t sau , vv):
except NameError as e : ... #  S·ª≠ d·ª•ng bi·∫øn ch∆∞a ƒë∆∞·ª£c x√°c ƒë·ªãnh 
except AttributeError as e :
    ... # Truy c·∫≠p thu·ªôc t√≠nh/ph∆∞∆°ng th·ª©c kh√¥ng t·ªìn t·∫°i(c·∫£ list, dict)
    x = []
    x.appendd(1)  # AttributeError: 'list' object has no attribute 'appendd'
except TypeError as e  :
    ... # Thao t√°c kh√¥ng h·ª£p l·ªá v·ªõi ki·ªÉu d·ªØ li·ªáu
    "5" + 3        # TypeError
    len(5)         # TypeError
    my_list[None]  # TypeError: list indices must be integers
except ValueError as e:
    ... # H·ª£p l·ªá c√≥ gi√° tr·ªã v·ªÅ ki·ªÉu nh∆∞ng kh√¥ng h·ª£p l·ªá v·ªÅ nghƒ©a.
    int("hello")     # ValueError
    list.index(99)   # ValueError: 99 is not in list
except IndexError as e: 
    ... # Truy c·∫≠p ch·ªâ s·ªë ngo√†i ph·∫°m vi.
    [1, 2][5]  # IndexError
except KeyError as e:
    # Key truy c·∫≠p kh√¥ng t·ªìn t·∫°i trong dict
    d = {'a': 1}
    d['b']  # KeyError
    # c√°ch tr√°nh 
    d.get('key', "") # d√πng default
    if 'key' in d: ... # d√πng in 
except UnboundLocalError:
    x = 0
    def f():
        x += 1  # UnboundLocalError
    # d√πng global

except RecursionError: ... # ƒê·ªá quy qu√° s√¢u (v∆∞·ª£t gi·ªõi h·∫°n ~1000).sys.getrecursionlimit()
# khi d√πng nhi·ªÅu ngo·∫°i l·ªá ph·∫£i d√πng tuple 
except (ModuleNotFoundError, ImportError) as e: ...#  M√¥-ƒëun kh√¥ng t·ªìn t·∫°i ho·∫∑c sai ƒë∆∞·ªùng d·∫´n. as e: ...#  M√¥-ƒëun kh√¥ng t·ªìn t·∫°i ho·∫∑c sai ƒë∆∞·ªùng d·∫´n.
except (FileNotFoundError, OSError): ...#  File kh√¥ng t·ªìn t·∫°i, quy·ªÅn truy c·∫≠p, disk full, vv
except (UnicodeError, UnicodeDecodeError, UnicodeEncodeError):... # ƒê·ªçc/ghi file v·ªõi m√£ h√≥a sai.
except StopIteration: ... # G·ªçi tr√™n iterator ƒë√£ h·∫øt.next()
except RuntimeError: ... #  L·ªói logic nghi√™m tr·ªçng (v√≠ d·ª•: chu tr√¨nh nh·∫≠p, tr√¨nh t·∫°o ƒë∆∞·ª£c s·ª≠a khi ƒëang ch·∫°y).
except: KeyboardInterrupt: ...
# ----üõ°Ô∏è Nguy√™n t·∫Øc v√†ng ƒë·ªÉ tr√°nh ngo·∫°i l·ªá :----
"""
    EAFP "D·ªÖ xin tha th·ª© h∆°n l√† xin ph√©p" ‚Üí D√πng khi l·ªói nguy hi·ªÉm ra try/except
    LBYL "Look Before You Leap" ‚Üí Ki·ªÉm tra ƒëi·ªÅu k
    X√°c th·ª±c ƒë·∫ßu v√†o -> Lu√¥n ki·ªÉm tra ƒë·∫ßu v√†o t·ª´ ng∆∞·ªùi d√πng/t·ªáp/m·∫°ng
    D√πng g·ª£i √Ω ki·ªÉu + mypy -> B·∫Øt l·ªói ngay t·ª´ dev time
    Kh√¥ng b·∫Øt tr·ªëngexcept: -> Lu√¥n c√≥ th·ªÉ ch·ªâ ƒë·ªãnh c·ª• th·ªÉ lo·∫°i ngo·∫°i l·ªá

"""

def risky_code():...
# ‚ùå R·∫§T NGUY HI·ªÇM
try:
    risky_code()
except:  # B·∫Øt c·∫£ KeyboardInterrupt, SystemExit!
    pass
# s·ªØa 
def handle_error():...
try:
    risky_code()
except ValueError as e:
    handle_error(e)

...
# ‚ùå Sai: ch·ªâ b·∫Øt `TypeError`, b·ªè qua `ValueError`
# except TypeError, ValueError:  # C√ö PH√ÅP L·ªñI ·ªü Python 3!
# s·ªØa >> 
try:...
except (TypeError, ValueError) as e:
    ...

...
try:
    x = 1 / 0
except ZeroDivisionError:
    print("L·ªói")
else:
    print("Kh√¥ng l·ªói")  # ‚ùå KH√îNG ch·∫°y
finally:
    print("Lu√¥n ch·∫°y")  # ‚úÖ Ch·∫°y
# D√πng else v√† finally kh√¥ng hi·ªÉu r√µ
# else: ch·ªâ ch·∫°y n·∫øu kh√¥ng c√≥ exception
# finally: lu√¥n ch·∫°y, k·ªÉ c·∫£ c√≥ return, break, continue

...
def f():
    try:
        return "from try"
    except:...
    # finally:
    #     return "from finally"  # ‚úÖ Ghi ƒë√®!

print(f())  # "from finally"
# ‚Üí C·∫©n th·∫≠n khi return trong finally! 

...
def risky():...
try:
    risky()
except ValueError:
    print("C√≥ l·ªói")  # ‚ùå M·∫•t th√¥ng tin l·ªói g·ªëc!

# s·ªØa  >>
import logging

try:
    risky()
except ValueError as e:
    logging.exception("L·ªói khi x·ª≠ l√Ω")  # Gi·ªØ nguy√™n stack trace
    # ho·∫∑c raise l·∫°i: raise

...
try:
    risky()
except ValueError:
    # ‚ùå M·∫•t stack trace g·ªëc
    raise ValueError("L·ªói m·ªõi")

# ‚úÖ Gi·ªØ nguy√™n stack trace
except ValueError:
    raise  # ‚Üê kh√¥ng c√≥ ƒë·ªëi s·ªë

# Ho·∫∑c: chain exception (Python 3)
except ValueError as e:
    raise RuntimeError("L·ªói m·ªõi") from e

# raise l·∫°i exception sai c√°ch ‚Üí m·∫•t stack trace g·ªëc

...
my_dict = {}
# ‚ùå Kh√¥ng c·∫ßn thi·∫øt ‚Äì d√πng if t·ªët h∆°n
try:
    value = my_dict['key']
except KeyError:
    value = None

# ‚úÖ T·ªët h∆°n:
value = my_dict.get('key')
#  D√πng try...except ƒë·ªÉ ki·ªÉm tra ƒëi·ªÅu ki·ªán (EAFP vs LBYL) ‚Äì l·∫°m d·ª•ng
# ‚Üí EAFP ("Easier to Ask for Forgiveness than Permission") l√† phong c√°ch Python,
# nh∆∞ng ƒë·ª´ng l·∫°m d·ª•ng khi c√≥ c√°ch ƒë∆°n gi·∫£n h∆°n. 


# config.py
DEBUG = True

# main.py
import config
config.DEBUG = False  # ‚úÖ OK

# Nh∆∞ng n·∫øu b·∫°n l√†m:
from config import DEBUG
DEBUG = False  # ‚ùå Ch·ªâ g√°n local trong main.py, kh√¥ng ƒë·ªïi config.DEBUG!
# ƒê√¢y l√† b·∫´y "import by value vs by reference" ‚Äî th·ª±c ch·∫•t l√† rebinding name. 
# namespace >>Built-in >>Global (module-level) >>Local (function-level) >>Enclosing (closure)
# Module object>> t·∫°o 1 object module trong namespace
# D√πng import module cho c·∫•u h√¨nh, tr·∫°ng th√°i, c·∫ßn t√≠nh r√µ r√†ng th√¨ d√πng object thay from, tr√°nh xuung ƒë·ªôt v·ªõi namespace
# Utils extendsion>>
# D√πng from module import func cho h√†m/h·∫±ng ch·ªâ ƒë·ªçc, d√πng tr·ª±c ti·∫øp  ,

# n·∫øu d√πng g√≥i package >> th√¨ ph·∫£i c·∫ßn __init__ >> ph√¢n chia h·ªá th·ªóng r√µ r√†ng 
# mypackage/__init__.py
# from .core import Engine
# from .utils import load_config, save_output
# from .exceptions import MyError

# __all__ = ['Engine', 'load_config', 'save_output', 'MyError']

...
# exec() v√† eval() ‚Äì ph·∫°m vi ƒë·ªông (dynamic scope)
#  exec/eval ph√° v·ª° LEGB th√¥ng th∆∞·ªùng ‚Üí d·ªÖ g√¢y l·ªói b·∫£o m·∫≠t v√† debug kh√≥. 
x = 10
exec("print(x)")  # ‚Üí 10 ‚úÖ

def f():
    x = 20
    exec("print(x)")  # ‚Üí 20 ‚úÖ

f()

...
x = "global"

class A:
    x = "class"
    def method(self):
        return x  # ‚Üí "global", KH√îNG ph·∫£i "class"!

print(A().method())  # "global" ‚úÖ
#  Class scope ‚Äì kh√¥ng ph·∫£i l√† enclosing scope!

# ‚ùó Ph·∫°m vi l·ªõp (class scope) KH√îNG ƒë∆∞·ª£c t√¨m trong LEGB khi ·ªü trong method!
# ‚Üí Method ch·ªâ th·∫•y: Local ‚Üí Enclosing (n·∫øu c√≥ closure) ‚Üí Global ‚Üí Built-in. 
class A:
    x = "A"

    def get_via_self(self):
        return self.x

    def get_via_class(self):
        return self.__class__.x

    def get_via_A(self):
        return A.x

class B(A):
    x = "B"

b = B()

print(b.get_via_self())     # ‚Üí "B" ‚úÖ (k·∫ø th·ª´a + override)
print(b.get_via_class())    # ‚Üí "B" ‚úÖ (l·∫•y t·ª´ l·ªõp th·ª±c t·∫ø c·ªßa b)
print(b.get_via_A())        # ‚Üí "A" ‚ùå (c·ª©ng v√†o A, kh√¥ng theo subclass!)


class A:
    def method(self):
        print("A")

class B(A):
    def method(self):
        print("B")
        super().method()

class C(A):
    def method(self):
        print("C")
        super().method()

class D(B, C):
    def method(self):
        print("D")
        super().method()

D().method()
# Output: D ‚Üí B ‚Üí C ‚Üí A (ƒë√∫ng nh·ªù MRO)
# ‚ùå Sai c√°ch g·ªçi ‚Üí b·ªè ph∆∞∆°ng th·ª©c chasuper()

...
class MyInt(int): pass
x = MyInt(5)
print(type(x) == int)      # False ‚ùå
print(isinstance(x, int))  # True ‚úÖ

...
class MyClass:
    def __init__(self, items=[]):  # ‚ùå Mutable default!
        self.items = items

# b·∫´y v·ªõi FIle 
# üî• 2. B·∫´y chu·ªói v√† m√£ h√≥a
# Tr√™n Windows, n·∫øu file kh√¥ng c√≥ encoding, open() d√πng encoding h·ªá th·ªëng
with open('file.txt') as f:  # ‚ùå Nguy hi·ªÉm!
    data = f.read()
#s·ªØa  >>
with open('file.txt', encoding='utf-8') as f:
    ...

...
# ‚ùå Tr·ªôn l·∫´n ƒë·ªëi t∆∞·ª£ng v√† chu·ªóiPath RCE
from pathlib import Path
p = Path("data") / "file.txt"
# ‚ùå
with open(p + ".bak") as f:  # L·ªói! Kh√¥ng th·ªÉ c·ªông Path + str b·∫±ng `+`
    ...
# ‚úÖ S·ª≠ d·ª•ng ho·∫∑c √©p d√¢y:/
with open(p.with_suffix('.txt.bak')) as f: ...

...
# ‚ö†Ô∏è NEVER DO THIS WITH UNTRUSTED DATA
# data = pickle.loads(user_input)  # RCE risk!




d = {[1,2]: "value"}  # ‚ùå TypeError: unhashable type: 'list'
print(d)

# 5. B·ªã b·∫´y v√† iterator ƒë√£ c·∫°n ki·ªát
nums = (x for x in range(3))
print(list(nums))  # [0, 1, 2]
print(list(nums))  # [] ‚Üê generator ƒë√£ "h·∫øt"


d = {[1, 2]: "value"}      # ‚ùå list kh√¥ng hash ƒë∆∞·ª£c
d = {{1, 2}: "value"}      # ‚ùå set kh√¥ng hash ƒë∆∞·ª£c
d = {{"a": 1}: "value"}    # ‚ùå dict kh√¥ng hash ƒë∆∞·ª£c
t = ([1, 2],)  # tuple ch·ª©a list ‚Üí v·∫´n unhashable!
d = {t: "x"}   # ‚ùå TypeError!
# ‚úÖ Ch·ªâ s·ª≠ d·ª•ng lo·∫°i kh√≥a l√†m vi·ªác b·∫•t bi·∫øn : int , flaot , str
# s·ªØa  >>
d = {(1, 2): "value"}      # ‚úÖ tuple ‚Üí OK
d = {frozenset([1, 2]): "v"}  # ‚úÖ frozenset ‚Üí OK

...
d = {'a': 1}
print(d['b'])  # ‚ùå KeyError
# ‚ùå Key truy c·∫≠p kh√¥ng t·ªìn t·∫°i ‚ÜíKeyError
# C√°ch 1: D√πng .get()
value = d.get('b', 'default')

# C√°ch 2: Ki·ªÉm tra tr∆∞·ªõc
if 'b' in d:
    print(d['b'])

# C√°ch 3: D√πng defaultdict
from collections import defaultdict
d = defaultdict(lambda: 'default')

...
# ‚ùå Edit dict khi ƒëang l·∫∑p ‚Üí (trong m·ªôt s·ªë tr∆∞·ªùng h·ª£p)RuntimeError
d = {'a': 1, 'b': 2}
for k in d:
    if k == 'a':
        del d[k]  # ‚ùå RuntimeError: dictionary changed size during iteration
#s·ªØa  >> 
# L·∫∑p tr√™n b·∫£n sao key
for k in list(d.keys()):
    if k == 'a':
        del d[k]

# Ho·∫∑c d√πng dict comprehension ƒë·ªÉ t·∫°o m·ªõi
d = {k: v for k, v in d.items() if k != 'a'}

...
# ‚ùå ƒê·ªëi s·ªë m·∫∑c ƒë·ªãnh c√≥ th·ªÉ thay ƒë·ªïi trong dict ‚Üí h√†nh ƒë·ªông b·∫•t ng·ªù
def add(key, value, target={}):  # ‚ùå dict mutable default!
    target[key] = value
    return target

print(add('a', 1))  # {'a': 1}
print(add('b', 2))  # {'a': 1, 'b': 2} ‚Üê G√å?!
# s·ªØa  >>
def add(key, value, target=None):
    if target is None:
        target = {}
    target[key] = value
    return target

...
# ‚ùå So s√°nh dict b·∫±ng ‚Üí lu√¥n (tr·ª´ khi c√πng ƒë·ªëi t∆∞·ª£ng)isFalse
d1 = {'a': 1}
d2 = {'a': 1}
print(d1 is d2)  # False ‚úÖ (ƒë√∫ng logic)
print(d1 == d2)  # True ‚úÖ
# Kh√¥ng sai, nh∆∞ng ƒë·ª´ng d√πng ƒë·ªÉ so s√°nh n·ªôi dung dict .is


a = b = []  # ‚ùå c√πng tr·ªè 1 list!
a.append(1)
print(b)  # [1] ‚Üê b·∫•t ng·ªù!

# s·ªØa >>
a = []
b = []
# ho·∫∑c
a, b = [], []

...
a = [[1, 2], [3, 4]]
b = a.copy()        # ho·∫∑c b = a[:]
b[0][0] = 999
print(a)  # [[999, 2], [3, 4]] ‚Üê b·ªã ·∫£nh h∆∞·ªüng!
# ‚ùå Sao ch√©p danh s√°ch n√¥ng (b·∫£n sao n√¥ng) v·ªõi danh s√°ch l·ªìng nhau
import copy
b = copy.deepcopy(a)

...
result = []
for i in range(1000):
    result = result + [i]  # ‚ùå T·∫°o list m·ªõi m·ªói l·∫ßn!
# ‚ùå S·ª≠ d·ª•ng ƒë·ªÉ k·∫øt n·ªëi danh s√°ch trong v√≤ng l·∫∑p ‚Üí O(n¬≤) ‚Üí ch·∫≠m+
#s·ªØa >> 
result = []
for i in range(1000):
    result.append(i)  # ‚úÖ O(1) amortized

# ho·∫∑c
result.extend(range(1000))

"""
## üî∏ 1. Sao ch√©p n√¥ng (Shallow Copy) vs Sao ch√©p s√¢u (Deep Copy)

### üéØ V·∫•n ƒë·ªÅ c·ªët l√µi:
Python **kh√¥ng sao ch√©p object khi g√°n**, m√† **t·∫°o th√™m tham chi·∫øu** ‚Üí thay ƒë·ªïi object g·ªëc ‚Üí object "sao ch√©p" c≈©ng thay ƒë·ªïi.

### üî∏ Shallow Copy (`copy.copy()` ho·∫∑c `.copy()`, `[:]`)
- **Sao ch√©p c·∫•p 1**: t·∫°o **object m·ªõi**, nh∆∞ng **c√°c ph·∫ßn t·ª≠ b√™n trong v·∫´n l√† tham chi·∫øu ƒë·∫øn object c≈©**.
- **Ch·ªâ an to√†n v·ªõi d·ªØ li·ªáu flat** (kh√¥ng l·ªìng).

#### ‚úÖ V√≠ d·ª• minh h·ªça:
```python
import copy

# --- Tr∆∞·ªùng h·ª£p 1: Danh s√°ch ph·∫≥ng (flat list) ---
a = [1, 2, 3]
b = a.copy()        # shallow copy
b[0] = 999
print(a)  # [1, 2, 3] ‚Üí kh√¥ng b·ªã ·∫£nh h∆∞·ªüng ‚Üí OK!

# --- Tr∆∞·ªùng h·ª£p 2: Danh s√°ch l·ªìng (nested list) ---
a = [[1, 2], [3, 4]]
b = a.copy()        # shallow copy ‚Üí B·∫™Y!
b[0][0] = 999
print(a)  # [[999, 2], [3, 4]] ‚Üí B·ªä ·∫¢NH H∆Ø·ªûNG! 
"""

...# t·ª´ kho√° del 
a = [1, 2, 3]
b = a          # b v√† a c√πng tr·ªè ƒë·∫øn [1,2,3]
del a          # x√≥a t√™n 'a', nh∆∞ng object [1,2,3] v·∫´n c√≤n v√¨ 'b' ƒëang tr·ªè
print(b)       # [1, 2, 3] ‚Üí v·∫´n in ƒë∆∞·ª£c!
# X√≥a t√™n, kh√¥ng x√≥a ƒë·ªëi t∆∞·ª£ng

...# X√≥a ph·∫ßn t·ª≠ trong v√πng ch·ª©a
my_list = [10, 20, 30]
del my_list[1]     # x√≥a ph·∫ßn t·ª≠ ·ªü index 1
print(my_list)     # [10, 30]

my_dict = {'x': 1, 'y': 2}
del my_dict['x']   # x√≥a key 'x'
print(my_dict)     # {'y': 2}


# -----------------------------------------------------------------------------------------------------------------------------------------------
#  1. C√°c n√¢ng c·∫•p t√≠ch h·ª£p c·ªßa lo·∫°i d·ªØ li·ªáu
# frozenset: phi√™n b·∫£n b·∫•t bi·∫øn c·ªßa , c√≥ th·ªÉ d√πng l√†m kh√≥a trong dict.set
# bytearray: phi√™n b·∫£n c√≥ th·ªÉ thay ƒë·ªïi c·ªßa .bytes
# memoryview: ƒë∆∞·ª£c ph√©p truy c·∫≠p b·ªô nh·ªõ c·ªßa ƒë·ªëi t∆∞·ª£ng m√† kh√¥ng ƒë∆∞·ª£c sao ch√©p ‚Üí hi·ªáu su·∫•t cao.
# range: is Immutable Sequence , Not List , and Lazy (ch·ªâ sinh gi√° tr·ªã khi c·∫ßn).
# namedtuple(t·ª´ ): tuple c√≥ tr∆∞·ªùng t√™n ‚Üí d·ªÖ ƒë·ªçc, hi·ªáu qu·∫£.collections
# deque: h√†ng ƒë·ª£i hai ƒë·∫ßu, t·ªëi ∆∞u cho ch√®n/x√≥a ·ªü 2 ƒë·∫ßu.
# Counter, ,defaultdictOrderedDict : c√°c bi·∫øn c√≥ th·ªÉ h·ªØu √≠ch.

#  2. Iterable, Iterator, Generator ‚Äì Chi ti·∫øt s√¢u
# S·ª± kh√°c bi·ªát gi·ªØa v√†iterableiterator :
# list, , ‚Üí c√≥ th·ªÉ l·∫∑p l·∫°i (c√≥ )strdict__iter__
# iter(list)‚Üí iterator (c√≥ )__next__
# H√†m t·∫°o ( ) so v·ªõi bi·ªÉu th·ª©c t·∫°o ( )yield(x for x in ...)
# yield from: tr√¨nh t·∫°o ƒë·∫°i bi·ªÉu
# send(), ,throw()close() : b·ªô t·∫°o ƒëi·ªÅu khi·ªÉn
# ƒê√£ h·∫øt iterator : d√πng xong m·ªôt l·∫ßn l√† h·∫øt ‚Üí kh√¥ng th·ªÉ d√πng l·∫°i ƒë∆∞·ª£c.

#  3. Tr√¨nh qu·∫£n l√Ω b·ªëi c·∫£nh ( ) ‚Äì T·ª± t·∫°owith
# S·ª≠ d·ª•ng , ƒë·ªÉ h·ªó tr·ª£ l·ªõp__enter____exit__with
# Ho·∫∑c d√πng ƒë·ªÉ t·∫°o t·ª´ tr√¨nh t·∫°o@contextlib.contextmanager
# from contextlib import contextmanager

# @contextmanager
# def timer():
#     start = time.time()
#     yield
#     print(f"Time: {time.time() - start}")


#  4. Decorator ‚Äì N√¢ng cao
# Decorator c√≥ tham s·ªë:@decorator(arg)
# Tr√¨nh trang tr√≠ l·ªõp
# functools.wrapsƒë·ªÉ ch·ª©a si√™u d·ªØ li·ªáu g·ªëc c·ªßa h√†m
# C√°c tr√¨nh trang tr√≠ t√≠ch h·ª£p: , ,@property@staticmethod@classmethod

# 5. Mi√™u t·∫£ & , ,__get____set____delete__
# C∆° ch·∫ø ƒë·∫±ng sau@property
# Cho ph√©p ki·ªÉm so√°t quy·ªÅn truy c·∫≠p thu·ªôc t√≠nh

# class Positive:
#     def __set_name__(self, owner, name):
#         self.name = name
#     def __get__(self, obj, objtype=None):
#         return obj.__dict__[self.name]
#     def __set__(self, obj, value):
#         if value <= 0:
#             raise ValueError("Must be positive")
#         obj.__dict__[self.name] = value

#  6. Metaclass ( , c·ªßa l·ªõp)__new____init__
# "Class of class" ‚Üí use ƒë·ªÉ t√πy ch·ªânh c√°ch t·∫°o l·ªõp
# √çt d√πng, nh∆∞ng r·∫•t m·∫°nh (Django, SQLAlchemy use)

# class Meta(type):
#     def __new__(cls, name, bases, dct):
#         dct['auto_added'] = True
#         return super().__new__(cls, name, bases, dct)

# class MyClass(metaclass=Meta):
#     pass

# üîπ 7. Kh√¥ng ƒë·ªìng b·ªô / Ch·ªù ƒë·ª£i (asyncio)
# L·∫≠p tr√¨nh b·∫•t ƒë·ªìng b·ªô: , , ,async defawaitasync forasync with
# V√≤ng l·∫∑p s·ª± ki·ªán, coroutine, nhi·ªám v·ª•, t∆∞∆°ng lai
# Kh√¥ng ph·∫£i ƒëa lu·ªìng, m√† l√† ƒë·ªìng th·ªùi th√¥ng qua ƒëa nhi·ªám h·ª£p t√°c

# üîπ 8. G·ª£i √Ω g√µ ‚Äì N√¢ng cao
# Union, , , ,OptionalLiteralTypedDictProtocol
# Generic: , ‚Üí thay b·∫±ng (Python 3.9+)List[int]Dict[str, float]list[int]
# TypeVar, ,Callable@overload
# D√πng ƒë·ªÉ ki·ªÉm tra tƒ©nhmypy

#  9. Module & Package ‚Äì N√¢ng cao
# __name__ == "__main__": check script run direct
# __all__: ki·ªÉm so√°tfrom module import *
# Nh·∫≠p kh·∫©u t∆∞∆°ng ƒë·ªëi:from . import utils
# G√≥i kh√¥ng gian t√™n (kh√¥ng c·∫ßn thi·∫øt )__init__.py


# üîπ 10. Hi·ªáu su·∫•t & T·ªëi ∆∞u h√≥a
# __slots__: gi·∫£m b·ªô nh·ªõ cho phi√™n b·∫£n
# tr√°nh cho string ‚Üí d√πng+join()
# Tr√°nh trong v√≤ng l·∫∑p ‚Üí s·ª≠ d·ª•ng ho·∫∑c hi·ªÉu danh s√°chlist + listextend()
# dismodule: xem bytecode
# timeit: performance ƒëo ch√≠nh x√°c
# üîπ 11. C√¥ng c·ª• g·ª° l·ªói & xem x√©t n·ªôi t√¢m
# inspectmodule: l·∫•y h√†m th√¥ng tin, l·ªõp, khung
# pprint: in ƒë·∫πp d·ªØ li·ªáu c·∫•u tr√∫c
# pdb: tr√¨nh g·ª° l·ªói t√≠ch h·ª£p
# vars(), , ,dir()getattr()hasattr()
# üîπ 12. GIL (Kh√≥a th√¥ng d·ªãch to√†n c·ª•c)
# T·∫°i sao Python kh√¥ng th·ª±c hi·ªán t·ªëi ƒëa lu·ªìng CPU-bound?
# Khi n√†o th√¨ n√™n s·ª≠ d·ª•ng ?multiprocessingthreading

# 13. L·ªõp d·ªØ li·ªáu (Python 3.7 tr·ªü l√™n)
# Thay th·∫ø , , b·∫±ng trang tr√≠__init____repr____eq__
# from dataclasses import dataclass

# @dataclass
# class Point:
#     x: int
#     y: int

#  14. So kh·ªõp m·∫´u c·∫•u tr√∫c (match-case ‚Äì Python 3.10+)
# match value:
#     case 0:
#         print("Zero")
#     case x if x > 0:
#         print("Positive")
#     case _:
#         print("Other")
    

# üîπ 15. B·∫£o m·∫≠t & Th·ª±c h√†nh t·ªët nh·∫•t
# Tr√°nh , , v·ªõi d·ªØ li·ªáu kh√¥ng ƒë∆∞·ª£c tin c·∫≠yeval()exec()pickle
# S·ª≠ d·ª•ng thay th·∫ø m·∫≠t kh·∫©u/m√£ th√¥ng b√°osecretsrandom
# M√¥i tr∆∞·ªùng ·∫£o ( , , )venvpipenvpoetry
